-- migrations/<timestamp>_create_system_gmail_config_and_enable_vault.sql

-- Ensure extensions are created first.
-- "pgsodium" is a dependency of "supabase_vault" and is usually
-- handled implicitly or explicitly before "supabase_vault".
-- It's good practice to ensure it's here if not handled elsewhere.
CREATE SCHEMA IF NOT EXISTS pgsodium;
-- ADD THIS LINE
CREATE EXTENSION IF NOT EXISTS "pgsodium" WITH SCHEMA pgsodium;

CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA vault;

-- Standard "moddatetime" extension
CREATE EXTENSION IF NOT EXISTS "moddatetime";

create table public.system_gmail_config (
    id bigint generated by default as identity,
    connected_email text not null,
    access_token text not null,
    expires_at timestamp
    with
        time zone not null,
        scopes text not null,
        vault_secret_id uuid not null,
        created_at timestamp
    with
        time zone null default now(),
        updated_at timestamp
    with
        time zone null default now(),
        constraint system_gmail_config_pkey primary key (id),
        constraint system_gmail_config_connected_email_key unique (connected_email),
        constraint system_gmail_config_vault_secret_id_fkey foreign key (vault_secret_id) references vault.secrets (id) on delete set null
);

alter table public.system_gmail_config enable row level security;

create trigger on_update_system_gmail_config before update on public.system_gmail_config
for each row execute procedure moddatetime (updated_at);

CREATE OR REPLACE FUNCTION public.vault_create_secret(
    p_name text,
    p_secret text,
    p_description text DEFAULT ''::text
)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO '$user', public, vault
AS $$
DECLARE
    v_secret_id UUID;
    v_error_message TEXT;
    v_error_sqlstate TEXT; -- Renamed for clarity, often just 'SQLSTATE' in older versions
BEGIN
    RAISE NOTICE 'DEBUG: public.vault_create_secret called with name=%, secret_length=%, description_length=%',
                 p_name, length(p_secret), length(p_description);

    BEGIN
        v_secret_id := vault.create_secret(p_secret, p_name, p_description);
        RAISE NOTICE 'DEBUG: vault.create_secret returned ID: %', v_secret_id;
        RETURN v_secret_id;
    EXCEPTION
        WHEN OTHERS THEN
            GET STACKED DIAGNOSTICS
                v_error_message = MESSAGE_TEXT,
                v_error_sqlstate = RETURNED_SQLSTATE; -- Use RETURNED_SQLSTATE for SQLSTATE

            RAISE WARNING 'ERROR: public.vault_create_secret caught exception. SQLSTATE: %, Message: %',
                          v_error_sqlstate, v_error_message;
            RETURN NULL;
    END;
END;
$$;

GRANT
EXECUTE ON FUNCTION public.vault_create_secret (TEXT, TEXT, TEXT) TO service_role;

CREATE OR REPLACE FUNCTION public.vault_get_secret(secret_id UUID) RETURNS TEXT AS $$
DECLARE
    secret_value TEXT;
BEGIN
    SELECT decrypted_secret INTO secret_value FROM vault.decrypted_secrets WHERE id = secret_id;
    RETURN secret_value;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT
EXECUTE ON FUNCTION public.vault_get_secret (UUID) TO service_role;